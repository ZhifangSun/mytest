import numpy
import math
from collections import Counter
import matplotlib.pyplot as plt
from xml.dom import minidom
doc = minidom.parse("heft.xml")
class final(object):
    def __init__(self):
        self.aaa=tuple()
    def equl(self,a):
        if not self.aaa:
            self.aaa=self.aaa+(a,)
        else:
            self.aaa[0]=a
    def ans(self):
        return self.aaa[0]

# tex=numpy.full((10,10),99999999)
# job = doc.getElementsByTagName("job")
# child = doc.getElementsByTagName("child")
# for i in child:
#     y=int(i.getAttribute("ref")[5:7])-1
#     for j in i.getElementsByTagName("parent"):
#         x=int(j.getAttribute("ref")[5:7])-1
#         for temp in job[x].getElementsByTagName("uses"):
#             if int(temp.getAttribute("file")[12:])==y+1:
#                 tex[x][y]=int(temp.getAttribute("size"))
# print(tex)
# q=final()            #等价于Java里的 final int q，q的类型也不一定是int，看后期插入的类型
# q.equl(2)            #等价于Java里的 q=2
# print(q.ans())       #等价于输出此时q的值
# print(type(q.ans())) #输出此时q的类型，在这里是int
# #q.equl(3)            #在前面已经存在q=2的情况下，这里再想对q进行赋值(q=3),程序就会报错
# print(q.ans())
#
# w=5
# w=w/2
# print(w)
Gamma = math.log(0.1 / 1, 0.2)#总迭代次数
print(Gamma)
# lis = numpy.zeros((4, 5))
# a=[]
# for i in range(32):  # 形成SearchAgents_no*30个数[-100，100)以内
#     b=[]
#     for j in range(5):
#         b.append(numpy.random.randint(5,30))
#     a.append(b)
# x=[481.3,475.79999999999995,456.8,456.8,456.8,427.6,427.6,420.2,420.2,420.2,411.0,400.2,397.40000000000003,383.6,383.6,383.6,383.6,383.6,383.6,363.09999999999997,363.09999999999997,363.09999999999997,362.7,362.7,355.5,352.8,351.09999999999997,342.0,342.0,342.0,342.0,342.0,331.20000000000005,328.1,328.1,324.29999999999995,324.29999999999995,324.29999999999995,324.29999999999995,324.29999999999995,324.29999999999995,320.70000000000005,320.70000000000005,320.70000000000005,320.70000000000005,304.0,304.0,304.0,304.0,304.0,289.7,289.7,289.7,289.7,289.7,289.7,289.7,289.7,289.7,284.1,284.1,284.1,282.7,282.7,281.3,281.3,281.3,281.3,281.3,281.3,281.1,281.1,276.4,276.4,276.4,276.4,276.4,276.4,276.4,276.4,275.2,275.2,273.1,273.1,273.0,273.0,270.5,270.5,270.5,270.5,270.5,270.5,270.5,270.5,270.5,269.8,269.8,269.09999999999997,267.2,267.2,267.2,267.2,267.2,267.2,267.2,263.59999999999997,261.0,252.9,252.9,252.9,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,246.3,]
# y=[479.3,479.3,479.3,466.9,447.90000000000003,447.90000000000003,428.5,428.5,428.5,412.2,412.2,390.2,390.2,384.09999999999997,384.09999999999997,384.09999999999997,384.09999999999997,384.09999999999997,384.09999999999997,384.09999999999997,370.1,370.1,370.1,370.1,370.1,370.0,370.0,370.0,355.3,354.6,354.6,351.40000000000003,351.40000000000003,351.40000000000003,351.40000000000003,349.40000000000003,349.40000000000003,349.40000000000003,349.40000000000003,349.40000000000003,346.7,337.2,337.2,327.90000000000003,327.90000000000003,327.90000000000003,327.90000000000003,327.90000000000003,327.90000000000003,327.90000000000003,294.5,294.5,294.5,294.5,294.5,294.5,294.5,294.5,291.1,291.1,291.1,291.1,288.4,287.2,270.4,270.4,270.4,270.4,270.4,269.5,269.5,269.5,269.3,268.6,268.6,267.9,267.9,267.5,267.5,267.5,267.4,267.4,267.4,266.7,266.7,266.7,266.7,266.7,266.7,266.7,266.7,266.7,266.7,266.5,266.5,266.3,266.3,266.3,266.2,266.1,266.1,266.1,266.1,266.1,266.1,265.8,265.8,265.8,265.8,265.8,265.8,265.8,265.8,265.8,265.8,265.8,265.8,265.8,265.8,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2,265.2]
# x_label = numpy.arange(0, len(x), 1)
# y_label = numpy.arange(0, len(y), 1)
# plt.plot(x_label[0:], x[0:], color='blue')
# plt.plot(y_label[0:], y[0:], color='red')
# plt.title('DE_GWO_AS')
# plt.xlabel('iteration')
# plt.ylabel('fx')
# plt.legend(('ASDE_GWO', 'GWO'))
# plt.savefig('./iteration-f.png')
# plt.show()
# # lis=sorted(lis,key=lambda x:sum(x))
# words = [1,1,8,7,8,6,4,4,5,9,9,9,9,3,1]
# collection_words = Counter(words)
# most_counterNum = collection_words.most_common(3)
# print(most_counterNum[0][1])